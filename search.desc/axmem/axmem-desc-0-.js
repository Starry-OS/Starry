searchState.loadedDescShard("axmem", 0, "The memory management module, which implements the memory …\nThe map from key to shmid. It’s used to query shmid from …\nA continuous virtual area in user memory.\nFile backend for Lazy load <code>MapArea</code>. <code>file</code> should be a file …\nPageTable + MemoryArea for a process (task)\nThis struct only hold SharedMem that are not IPC_PRIVATE. …\nPanics: shmid is already taken in the process.\nPanics: shmid is already taken.\nreturn whether all the pages have been allocated.\nSafety\nAttach a SharedMem to the memory set.\nwhether the area is backed by a file\n验证地址是否已分配页面\nClone the area.\nClone the MemorySet. This will create a new page table and …\nclone a new <code>MemBackend</code> with a delta offset of the file of …\nIf [start, end] contains self.\nIf self contains [start, end].\nCreate a new SharedMem with given key. You need to add the …\nDeallocate all phys pages and unmap the area in page table.\nDetach a SharedMem from the memory set.\nreturn the end virtual address of the area.\nFill <code>self</code> with <code>byte</code>.\nFind a free area with given start virtual address and …\nmapping flags of this area\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a private SharedMem by shmid.\nGet a SharedMem by shmid.\n…\nIt will map newly allocated page in the page table. You …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n判断某一个虚拟地址是否在内存集中。 …\n暴力实现区间强制分配 传入区间左闭右闭\n判断某一个类型的某一个对象是否被分配\nMap a 4K region without allocating physical memory.\nThe max virtual address of the areas in this memory set.\nmmap. You need to flush tlb after this.\nEdit the page table to update flags in given virt address …\nmremap: change the size of a mapping, potentially moving …\nmsync\nmunmap. You need to flush TLB after this.\nCreate a new <code>MemBackend</code> with a file and the seek offset of …\nAllocated an area and map it in page table.\nCreate a new empty MemorySet.\nCreate a lazy-load area and map it in page table (page …\nCreate a new MemorySet\nAllocate contiguous region. If no data, it will create a …\nIf [start, end) overlaps with self.\nThe root page table physical address.\nGet the root page table token.\nphys pages of this area\nQuery the page table to get the physical address, flags …\nread from the file of the <code>MemBackend</code> with a pos offset.\nwhether the file of the <code>MemBackend</code> is readable.\nCreate a second area in the right part of the area, […\nDeallocate some pages from the start of the area. This …\nDeallocate some pages from the end of the area. This …\nreturn the size of the area, which thinks the page size is …\nSplit this area into 2.\nSplit this area into 3.\nMake [start, end) unmapped and dealloced. You need to …\nIf self strictly contains [start, end], which stands for …\nSync pages in index back to <code>self.backend</code> (if there is one).\n…\nUpdate area’s mapping flags and write it to page table. …\nstart virtual address\nwhether the file of the <code>MemBackend</code> is writable.\nwrite to the file of the <code>MemBackend</code> with a pos offset.")